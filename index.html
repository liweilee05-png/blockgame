<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>打磚塊遊戲</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function BreakoutGame() {
            const canvasRef = useRef(null);
            const [gameStarted, setGameStarted] = useState(false);
            const [score, setScore] = useState(0);
            const [finalScore, setFinalScore] = useState(0);
            const gameStateRef = useRef({
                balls: [{ x: 250, y: 50, velX: 3, velY: 2, id: 0, isBonus: false }],
                powerUps: [],
                paddleX: 175,
                paddleWidth: 150,
                speed: 2,
                nextBallId: 1,
                nextPowerUpId: 0,
                powerUpSpawnCounter: 0,
                ballAddCount: 0,
                hitCount: 0
            });
            const [displayState, setDisplayState] = useState(gameStateRef.current);

            const paddleHeight = 15;
            const ballRadius = 10;
            const powerUpRadius = 8;
            const canvasWidth = 500;
            const canvasHeight = 400;

            useEffect(() => {
                const handleMouseMove = (e) => {
                    const canvas = canvasRef.current;
                    if (!canvas) return;
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    gameStateRef.current.paddleX = Math.max(0, Math.min(x - gameStateRef.current.paddleWidth / 2, canvasWidth - gameStateRef.current.paddleWidth));
                };

                const handleKeyDown = (e) => {
                    if (e.key === 'ArrowLeft') {
                        gameStateRef.current.paddleX = Math.max(0, gameStateRef.current.paddleX - 15);
                    }
                    if (e.key === 'ArrowRight') {
                        gameStateRef.current.paddleX = Math.min(canvasWidth - gameStateRef.current.paddleWidth, gameStateRef.current.paddleX + 15);
                    }
                };

                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('keydown', handleKeyDown);
                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('keydown', handleKeyDown);
                };
            }, []);

            useEffect(() => {
                if (!gameStarted) return;

                const interval = setInterval(() => {
                    const state = gameStateRef.current;
                    const { balls, powerUps, paddleX, paddleWidth, speed } = state;

                    state.powerUpSpawnCounter++;
                    if (state.powerUpSpawnCounter > 150 && balls.length > 0) {
                        state.powerUpSpawnCounter = 0;
                        const newPowerUp = {
                            x: Math.random() * (canvasWidth - 40) + 20,
                            y: Math.random() * (canvasHeight * 0.5) + 50,
                            velX: 0,
                            velY: 0,
                            type: 'paddle_extend',
                            id: state.nextPowerUpId
                        };
                        state.nextPowerUpId++;
                        powerUps.push(newPowerUp);
                    }

                    balls.forEach(ball => {
                        ball.x += ball.velX * speed;
                        ball.y += ball.velY * speed;

                        if (ball.x - ballRadius < 0 || ball.x + ballRadius > canvasWidth) {
                            ball.velX = -ball.velX;
                            ball.x = Math.max(ballRadius, Math.min(canvasWidth - ballRadius, ball.x));
                        }

                        if (ball.y - ballRadius < 0) {
                            ball.velY = -ball.velY;
                            ball.y = ballRadius;
                        }

                        if (
                            ball.y + ballRadius >= canvasHeight - paddleHeight &&
                            ball.y - ballRadius <= canvasHeight &&
                            ball.x >= paddleX &&
                            ball.x <= paddleX + paddleWidth &&
                            ball.velY > 0
                        ) {
                            ball.velY = -Math.abs(ball.velY);
                            ball.y = canvasHeight - paddleHeight - ballRadius;

                            const points = ball.isBonus ? 2 : 1;
                            setScore(s => s + points);

                            state.hitCount++;

                            if (state.hitCount % 3 === 0) {
                                state.speed += 0.25;
                                state.ballAddCount++;
                                const isBonus = state.ballAddCount % 2 === 0;

                                const newBall = {
                                    x: Math.random() * (canvasWidth - 40) + 20,
                                    y: 30,
                                    velX: (Math.random() - 0.5) * 4,
                                    velY: 2,
                                    id: state.nextBallId,
                                    isBonus: isBonus
                                };
                                state.nextBallId++;
                                balls.push(newBall);
                            } else {
                                state.speed += 0.25;
                            }
                        }

                        for (let i = powerUps.length - 1; i >= 0; i--) {
                            const pu = powerUps[i];
                            const dist = Math.sqrt((ball.x - pu.x) ** 2 + (ball.y - pu.y) ** 2);

                            if (dist < ballRadius + powerUpRadius) {
                                if (pu.type === 'paddle_extend') {
                                    state.paddleWidth = Math.min(250, state.paddleWidth + 40);

                                    setTimeout(() => {
                                        state.paddleWidth = Math.max(150, state.paddleWidth - 40);
                                    }, 3000);
                                }
                                powerUps.splice(i, 1);
                            }
                        }
                    });

                    for (let i = balls.length - 1; i >= 0; i--) {
                        if (balls[i].y > canvasHeight) {
                            balls.splice(i, 1);
                        }
                    }

                    if (balls.length === 0) {
                        setGameStarted(false);
                        setFinalScore(score);
                        gameStateRef.current = {
                            balls: [{ x: 250, y: 50, velX: 3, velY: 2, id: 0, isBonus: false }],
                            powerUps: [],
                            paddleX: 175,
                            paddleWidth: 150,
                            speed: 2,
                            nextBallId: 1,
                            nextPowerUpId: 0,
                            powerUpSpawnCounter: 0,
                            ballAddCount: 0,
                            hitCount: 0
                        };
                        return;
                    }

                    setDisplayState({ ...state });
                }, 30);

                return () => clearInterval(interval);
            }, [gameStarted, score]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = '#e8f4f8';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, canvasHeight / 2);
                ctx.lineTo(canvasWidth, canvasHeight / 2);
                ctx.stroke();
                ctx.setLineDash([]);

                displayState.powerUps.forEach(pu => {
                    if (pu.type === 'paddle_extend') {
                        ctx.fillStyle = '#ffd93d';
                        ctx.beginPath();
                        ctx.arc(pu.x, pu.y, powerUpRadius, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.strokeStyle = '#ff6b6b';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(pu.x - 4, pu.y);
                        ctx.lineTo(pu.x + 4, pu.y);
                        ctx.moveTo(pu.x, pu.y - 4);
                        ctx.lineTo(pu.x, pu.y + 4);
                        ctx.stroke();
                    }
                });

                displayState.balls.forEach(ball => {
                    ctx.fillStyle = ball.isBonus ? '#ffd700' : '#ff6b6b';
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
                    ctx.fill();

                    if (ball.isBonus) {
                        ctx.fillStyle = '#ff6b6b';
                        ctx.font = 'bold 10px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('×2', ball.x, ball.y);
                    }
                });

                ctx.fillStyle = '#4ecdc4';
                ctx.fillRect(displayState.paddleX, canvasHeight - paddleHeight, displayState.paddleWidth, paddleHeight);

                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, canvasWidth, canvasHeight);
            }, [displayState]);

            return (
                <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-blue-50 to-cyan-50 p-4">
                    <div className="bg-white rounded-lg shadow-lg p-8">
                        <h1 className="text-3xl font-bold text-center mb-2 text-gray-800">打磚塊遊戲</h1>
                        <p className="text-center text-gray-600 mb-2">每碰到 3 次就加一顆球，速度更快！</p>
                        <p className="text-center text-yellow-600 text-sm mb-6">💛 收集黃色道具讓球拍變長！🟡 金色球得 2 分！</p>

                        <canvas
                            ref={canvasRef}
                            width={canvasWidth}
                            height={canvasHeight}
                            className="border-2 border-gray-300 rounded-lg mb-6 bg-white cursor-none"
                        />

                        <div className="text-center mb-4">
                            <p className="text-2xl font-bold text-blue-600">分數: {gameStarted ? score : finalScore}</p>
                            <p className="text-lg text-gray-600">球數: {displayState.balls.length} | 速度: {displayState.speed.toFixed(1)}x | 球拍寬: {displayState.paddleWidth}</p>
                        </div>

                        <button
                            onClick={() => {
                                if (!gameStarted) {
                                    gameStateRef.current = {
                                        balls: [{ x: 250, y: 50, velX: 3, velY: 2, id: 0, isBonus: false }],
                                        powerUps: [],
                                        paddleX: 175,
                                        paddleWidth: 150,
                                        speed: 2,
                                        nextBallId: 1,
                                        nextPowerUpId: 0,
                                        powerUpSpawnCounter: 0,
                                        ballAddCount: 0,
                                        hitCount: 0
                                    };
                                    setScore(0);
                                    setDisplayState(gameStateRef.current);
                                }
                                setGameStarted(!gameStarted);
                            }}
                            className="w-full py-3 px-6 bg-blue-500 hover:bg-blue-600 text-white font-bold rounded-lg transition"
                        >
                            {gameStarted ? '暫停' : '開始遊戲'}
                        </button>

                        <div className="mt-6 text-gray-700 text-sm">
                            <p className="mb-2"><strong>控制方式：</strong></p>
                            <p>🖱️ 移動滑鼠控制球拍</p>
                            <p>⌨️ 或使用左右箭頭鍵移動球拍</p>
                            <p className="mt-3"><strong>道具說明：</strong></p>
                            <p>💛 黃色道具 - 球碰到會讓球拍變長 3 秒</p>
                            <p>🟡 金色球 - 碰到球拍得 2 分（每加 2 次球出現）</p>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<BreakoutGame />, document.getElementById('root'));
    </script>
</body>
</html>